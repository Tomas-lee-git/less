// variables
@color: pink;
@bgColor: skyblue;
@width: 100%;
@link-color: #428bca;
@link-hover-color: darken(@link-color, 10%);
.wrap {
    color: @color;
    background-color: @link-color;
    width: @width;
    height: @width;
}

.border {
    border-top: 1px solid rgb(168, 6, 6);
    border-bottom: 1px solid rgb(139, 176, 190);
}

#menu a {
    color: yellowgreen;
    &:hover {
        color: @link-hover-color;
    }
}

// selectors
@my-selector: banner;
.@{my-selector} {
    color: yellow;
}

// urls
@images: "./images";
body {
    background: url("@{images}/2.jpg")
}

// import Statements
@themes: "../../src/themes";
// @import "@{themes}/tidal-wave.less"
// properties
@bg: background;
body {
    @{bg}-color: red;
}

// variable variables
// @c:bg;
// @bgc:@@c;
// body{
//     @{bgc}-color:blue;
// }
// lazy evaluation
// variables do not have to be declared before being used.
@c: bg;
body {
    @{bgc}-color: blue;
}

@bgc: @@c;
@bgc: border;
@bgc: background;
/*
When defining a variable twice, the last definition of the variable is used, 
searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.
*/

@bgc: border;
@bgc: background;
// Properties as Variables (NEW!)
.first {
    color: #efefef;
    background-color: $color;
}

// parent selectors
body {
    .forth {
        font-size: 20px;
        color: #000; //  & p:first-child{
        //      color:red;
        //  }
        //  & p:last-child{
        //     color:green;
        // }
        &:hover {
            font-size: 50px;
        }
    }
}

// Combinatorial Explosion
// & can also be used to generate every possible permutation of selectors in a comma separated list:
p,
a,
ul,
li {
    border-top: 2px dotted #366;
    &+& {
        border-top: 0px;
    }
}

//   This expands to all possible (16) combinations of the specified elements:
p,
a,
ul,
li {
    border-top: 2px dotted #366;
}

p+p,
p+a,
p+ul,
p+li,
a+p,
a+a,
a+ul,
a+li,
ul+p,
ul+a,
ul+ul,
ul+li,
li+p,
li+a,
li+ul,
li+li {
    border-top: 0;
}

//extends
.forth {
    p {
        &:extend(.color);
    }
}

.color {
    color: pink;
}

// extend "all"
.f {
    color: green;
    font-size: 20px;
    font-style: italic;
}

.fifth:extend(.fifth all) {}

// Top level extend matches everything including selectors inside nested media:
.f {
    color: green;
    font-size: 20px;
    font-style: italic;
    span {
        color: red;
        font-size: 30px;
    }
}

.fifth:extend(.f span) {}

.fifth {
    &:extend(f,
    span);
    span {
        color: black;
    }
}

// mixin
.blue-italic() {
    color: blue;
    font-style: italic;
    font-size: 25px;
    box-shadow+: inset 0 0 10px #555;
}

// Merge
.sixth {
    .blue-italic();
    box-shadow+: 0 0 10px #555;
}

// mixins
.hover() {
    &:hover {
        font-size: 40px;
        color: darkblue;
    }
}

.sixth {
    .hover();
}

// Namespaces
#my-library {
    .i-color() {
        i {
            color: #fff;
        }
    }
}

.sixth {
    #my-library>.i-color();
}

// Guarded Namespaces

#namespace {
    .mixin() when (@mode = huge) { /* */ }
  }

  //!important 

  .foo (@bg: #f5f5f5, @color: #900) {
    background: @bg;
    color: @color;
  }
  .unimportant {
    .foo();
  }
  .important {
    .foo() !important;
  }
// result in
  .important {
    background: #f5f5f5 !important;
    color: #900 !important;
  }

//   Parametric Mixins
.length(@length:200px){
    width: @length;
    height: @length/2;
    font-size: @length/5;
}
#seventh{
    .length(500px)
}
#seventh{
    .length()
}